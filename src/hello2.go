package main

//
///**
//数据类型:整型与浮点型
//*/
//func main() {
//	/**
//	1.3.1 整型
//	int   符号   数据类型   类型宽度(bit) 类型宽度(byte) 备注
//	      有    int        32或64       4或8         与计算机系统的位数有关
//	      有    int8       8            1
//	      有    int16      16           2
//	      有    int32      32           4            相当于32位系统下的int类型
//	      有    int64      64           8            相当于64位系统下的int类型
//
//	unit  无    unit       32或64       4或8          与...
//	      无    unit8      8            1
//	      无    unit16     16           2
//	      无    unit32     32           4             相当于32位系统下的unit类型
//	      无    unit64     64           8             相当于64位系统下的unit类型
//	*/
//	//解释 以int8 和unit8举例e,8代表8个bit，能表示的数值个数有2^8=256.
//	//unit8是无符号,能表示的都是正数，0-255,刚好256个数.
//	//int是有符号，既可以正数,也可以负数.-128-127,刚好256个数.
//	//int8 int16 int32 int64 这几个类型的最后都有一个数值,这表明了它们能表示的数值个数是固定的
//	//而int并没有指定它的位数，说明它的大小，是可以变化的
//	//1.当你在32位的系统下，int和unit都占用4个字节，也就是32位.
//	//2.当你在64位的系统下，int和unit都占用8个字节,也就是64位.
//	//出于这个原因，在某些场景下，你应当避免使用int和unit，而使用更加精确的int32和int64，比如在二进制传输，读写文件的结构描述（为了保持文件的
//	//结构不会受到不同编译目标平台字节长度的影响)
//
//	//不同进制的表示方法
//	// 整型 => 10进制
//	//var num int = 10
//	// 2进制: 以0b或0B为前缀
//	//var num01 int = 0b1100
//	// 8进制: 以0o或者0O
//	//var num02 int = 0o14
//	//16进制: 以0x
//	//var num03 int = 0xC
//
//	//fmt格式化功能
//	//%b    表示为二进制
//	//%c    该值对应的unicode码值
//	//%d    表示为十进制
//	//%o    表示为八进制
//	//%q    该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示
//	//%x    表示为十六进制，使用a-f
//	//%X    表示为十六进制，使用A-F
//	//%U    表示为Unicode格式：U+1234，等价于"U+%04X"
//	//%E    用科学计数法表示
//	//%f    用浮点数表示
//
//	//fmt.Printf("2进制数 %b 表示的是: %d \n", num01, num01)
//	//fmt.Printf("8进制数 %o 表示的是: %d \n", num02, num02)
//	//fmt.Printf("16进制数 %X 表示的是: %d \n", num03, num03)
//	//输出
//	//2进制数 1100 表示的是: 12
//	//8进制数 14 表示的是: 12
//	//16进制数 C 表示的是: 12
//
//	/**
//			1.3.2 浮点型
//			浮点数类型的值一般由整数部分、小数点“.”和小数部分组成。
//
//			其中，整数部分和小数部分均由10进制表示法表示。不过还有另一种表示方法。那就是在其中加入指数部分。指数部分由“E”或“e”以及一个带正负号的10进制数组成。比如，3.7E-2表示浮点数0.037。又比如，3.7E+1表示浮点数37。
//
//			有时候，浮点数类型值的表示也可以被简化。比如，37.0可以被简化为37。又比如，0.037可以被简化为.037。
//
//			有一点需要注意，在Go语言里，浮点数的相关部分只能由10进制表示法表示，而不能由8进制表示法或16进制表示法表示。比如，03.7表示的一定是浮点数3.7。
//		    loat32 和 float64
//			Go语言中提供了两种精度的浮点数 float32 和 float64。
//
//			float32，也即我们常说的单精度，存储占用4个字节，也即4*8=32位，其中1位用来符号，8位用来指数，剩下的23位表示尾数
//	        / -----------  假装这是一个图片  ----------/
//	        0 0 1 1 1 1 1 1 0 0 0 ｜ 0 1 0 -- 19个0  -- 0 = 0.15625
//		    31 30                23   22                 0
//			float64，也即我们熟悉的双精度，存储占用8个字节，也即8*8=64位，其中1位用来符号，11位用来指数，剩下的52位表示尾数
//	          / ---------- 假装这是一个图片 -------------/
//
//		     0 ---- 9个0 ------ 0 ｜ 0 ---- 51个0 ---- 0
//		     63                 52                    0
//		那么精度是什么意思？有效位有多少位？
//
//		精度主要取决于尾数部分的位数。
//
//		对于 float32（单精度）来说，表示尾数的为23位，除去全部为0的情况以外，最小为2^-23，约等于1.19*10^-7，所以float小数部分只能精确到后面6位，加上小数点前的一位，即有效数字为7位。
//
//		同理 float64（单精度）的尾数部分为 52位，最小为2^-52，约为2.22*10^-16，所以精确到小数点后15位，加上小数点前的一位，有效位数为16位。
//
//		通过以上，可以总结出以下几点：
//
//		一、float32 和 float64 可以表示的数值很多
//
//		浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到：
//
//		常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；
//
//		常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；
//
//		float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。
//
//		二、数值很大但精度有限
//
//		人家虽然能表示的数值很大，但精度位却没有那么大。
//
//		float32的精度只能提供大约6个十进制数（表示后科学计数法后，小数点后6位）的精度
//
//		float64的精度能提供大约15个十进制数（表示后科学计数法后，小数点后15位）的精度
//
//		这里的精度是什么意思呢？
//
//		比如 10000018这个数，用 float32 的类型来表示的话，由于其有效位是7位，将10000018 表示成科学计数法，就是 1.0000018 * 10^7，能精确到小数点后面6位。
//
//		此时用科学计数法表示后，小数点后有7位，刚刚满足我们的精度要求，意思是什么呢？此时你对这个数进行+1或者-1等数学运算，都能保证计算结果是精确的
//	*/
//
//	//var myfloat float32 = 10000018
//	//fmt.Println("myfloat: ", myfloat)
//	//fmt.Println("myfloat: ", myfloat+1)
//
//	//输出
//	// myfloat:  1.0000018e+07
//	// myfloat:  1.0000019e+07
//
//	//上面举了一个刚好满足精度要求数据的临界情况，为了做对比，下面也举一个刚好不满足精度要求的例子。
//	//只要给这个数值多加一位数就行了。
//	//
//	//换成 100000187，同样使用 float32类型，表示成科学计数法，由于精度有限，表示的时候小数点后面7位是准确的，
//	//但若是对其进行数学运算，由于第八位无法表示，所以运算后第七位的值，就会变得不精确。
//	//
//	//这里我们写个代码来验证一下，按照我们的理解下面 myfloat01 = 100000182 ，
//	//对其+5 操作后，应该等于 myfloat02 = 100000187，
//
//	//var myfloat01 float32 = 100000182
//	//var myfloat02 float32 = 100000187
//	//
//	//fmt.Println("myfloat: ", myfloat01)
//	//fmt.Println("myfloat: ", myfloat01+5)
//	//fmt.Println(myfloat02 == myfloat01+5)
//
//	//输出
//	//myfloat:  1.00000184e+08
//	//myfloat:  1.0000019e+08
//	//false  但是由于其类型是 float32，精度不足，导致最后比较的结果是不相等（从小数点后第七位开始不精确）
//}
